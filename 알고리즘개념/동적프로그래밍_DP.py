'''
[ 동적프로그래밍 개념 ]
    1. 해결된 문제의 답을 저장해두고 그것을 재활용하여 해결된 문제를 다시 푸는 비효율을 제거
    2. 공간복잡도를 늘리고 시간복잡도를 줄이는 방식
'''

'''
[DP 사용 경우]
 - 최적 부분문제 구조(Optimal substructure)
 - 중복 부분문제 구조(Overlapping subproblems)

[ 3단계 DP 적용 접근 방법 ]
  1. 최적해 구조의 특성을 파악하라
     - 문제를 부분 문제로 나눈다.
  2. 최적해의 값을 재귀적으로 정의하라
     - 부분 문제의 최적해 값에 기반하여 문제의 최적해 값을 정의한다.
  3. 상향식 방법으로 최적해의 값을 계산하라
     - 가장 작은 부분 문제부터 해를 구한 뒤 테이블에 저장한다.
     - 테이블에 저장되어 있는 부분 문제의 해를 이용하여 점차적으로 상위 부분 문제의 최적해를 구한다. (상향식 방법)
'''


# 예제1. 피보나치 수 DP 적용
def fibo(n):
    f = [0, 1]
    for i in range(2, n + 1):
        f.append(f[i - 1] + f[i - 2])
    return f
print(fibo(10))


# 예제2. 백준 1463_1로 만들기
'''
[연산 방법]
1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
2. X가 2로 나누어 떨어지면, 2로 나눈다.
3. 1을 뺀다.
'''

'''
[풀이 방법]
1. X가 2로 나누어지면 2로 나누고, 3으로 나누어질 때는 3으로 나눔 -> but 예외 존재
   1-1. 예를 들어 10은 2로 나눌 경우 4번(10->5->4->2->1)의 연산이 필요하지만 최소값은 3번(10->9->3->1)이다.
   1-2. 10 -> 9 -> 8 -> 4 -> 2 -> 1
                          -> 3 -> 1
                -> 3 -> 1
           -> 5 -> 4 -> 2 -> 1
                     -> 3 -> 1
        이때, 3, 4 등 겹치는 부분이 발생
    if not n % 3(n%3==0): dp[n] = min(dp[n-1], dp[n//3])
    if not n % 2(n%2==0): dp[n] = min(dp[n-1], dp[n//2])
'''
x = int(input())

dp = [0 for _ in range(x + 1)]
dp[1] = 0  # 1은 연산방법1, 2, 3중에 사용할 수 있는 것이 없음

for i in range(2, x + 1):
    dp[i] = dp[i - 1] + 1
    if i % 2 and dp[i] > dp[i//2] + 1:  # 홀수이고, 갯수가 더 작으면
        dp[i] = dp[i//2] + 1  # 더 작은 값으로 갱신
    if i % 3 and dp[i] > dp[i//3] + 1:  # 홀수이고,
        dp[i] = dp[i//3] + 1

print(dp)


# 예제3. 백준11726_2xn 타일링
# 2×n 크기의 직사각형을 1×2, 2×1 타일로 채우는 방법의 수를 구하기
'''
[풀이방법]
1. 1×2, 2×1 타일이 마지막에 올 수 있는 경우는 2가지
   1-1. dp[n-1], 1×2 타일 1개
   1-2. dp[n-2], 2×1 타일 2개
2. 2xn 크기의 사각형을 채우는 방법은 1-1 + 1-2 경우
'''

n = int(input())

dp = [0 for _ in range(n + 1)]
dp[1] = 1  # 2×1 -> 2×1 타일 1개
dp[0] = 1  # dp[2] = 2x2 -> 1x2 2개 / 2x1 2개 => 2개
           # dp[2] = 2이므로 dp[0] = 1로 설정

for i in range(2, n+1):
    dp[i] = dp[i-1] + dp[i-2]
    # dp[2] = 2x2 -> 1x2 2개 / 2x1 2개 => 2개
print(dp[n] % 10007)


# 예제4. 백준10844_쉬운 계단 수
'''
45656 -> 인접한 모든 자리수의 차이가 1 -> 계단 수라고 한다.
N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지?(0으로 시작하는 수는 없다.)
'''

'''
ex
N = 1 => 1, 2, 3, 4, 5, 6 ...
N = 2 => 10, 12, 21, 23, 32, 34, 43, 45...
'''

# 길이가 N일 때, 마지막 수가 L일 경우의 계단의 수
# L=0 => dp[N][L] = dp[N-1][L+1]
# L=1~8 => dp[N][L] = dp[N-1][L-1] + dp[N-1][L+1]
# L=9 => dp[N][L] = dp[N-1][L-1]

N = int(input())
dp = [[0] * 10 for _ in range(N+1)]

for i in range(1, 10):
    dp[1][i] = 1

for i in range(2, N+1):
    for j in range(10):
        if j == 0:
            dp[i][j] += dp[i - 1][j + 1]
        elif 1 <= j <= 8:
            dp[i][j] += dp[i-1][j-1] + dp[i-1][j+1]
        elif j == 9:
            dp[i][j] += dp[i - 1][j - 1]

ans = 0
for i in range(10):
    ans += dp[N][i]

print(ans % 1000000000)


# 예제5. 백준11057_오르막 수